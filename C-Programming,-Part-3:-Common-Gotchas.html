<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<link rel="stylesheet" href="http://yui.yahooapis.com/pure/0.6.0/pure-min.css">
	<link rel="stylesheet" href="style.css">
    <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
</head>
<body>
<p>What common mistakes do C programmers make?</p>
<h1>Memory mistakes</h1>
<h2>String constants are constant</h2>
<div class="highlight"><pre><span class="kt">char</span> <span class="n">array</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;Hi!&quot;</span><span class="p">;</span> <span class="c1">// array contains a mutable copy </span>
<span class="n">strcpy</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="s">&quot;OK&quot;</span><span class="p">);</span>

<span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="s">&quot;Can&#39;t change me&quot;</span><span class="p">;</span> <span class="c1">// ptr points to some immutable memory</span>
<span class="n">strcpy</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="s">&quot;Will not work&quot;</span><span class="p">);</span>
</pre></div>


<p>String literals are character arrays stored in static memory, which is immutable. Two string literals may share the same space in memory. An example follows:</p>
<div class="highlight"><pre><span class="kt">char</span> <span class="o">*</span> <span class="n">str1</span> <span class="o">=</span> <span class="s">&quot;Brandon Chong is the best TA&quot;</span><span class="p">;</span>
<span class="kt">char</span> <span class="o">*</span> <span class="n">str2</span> <span class="o">=</span> <span class="s">&quot;Brandon Chong is the best TA&quot;</span><span class="p">;</span>
</pre></div>


<p>The strings pointed to by <code>str1</code> and <code>str2</code> may actually reside in the same location in memory.</p>
<p>Char arrays, however, put that string literal in static memory, <em>and then copy it over to stack memory</em>. These following char arrays do not reside in the same place in memory.</p>
<div class="highlight"><pre><span class="kt">char</span> <span class="n">arr1</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;Brandon Chong didn&#39;t write this&quot;</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">arr2</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;Brandon Chong didn&#39;t write this&quot;</span><span class="p">;</span>
</pre></div>


<h2>Buffer overflow/ underflow</h2>
<div class="highlight"><pre><span class="cp">#define N (10)</span>
<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">N</span><span class="p">,</span> <span class="n">array</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
<span class="k">for</span><span class="p">(</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</pre></div>


<p>C does not check that pointers are valid. The above example writes into <code>array[10]</code> which is outside the array bounds. This can cause memory corruption because that memory location is probably being used for something else.<br />
In practice, this can be harder to spot because the overflow/underflow may occur in a library call e.g.</p>
<div class="highlight"><pre><span class="n">gets</span><span class="p">(</span><span class="n">array</span><span class="p">);</span> <span class="c1">// Let&#39;s hope the input is shorter than my array!</span>
</pre></div>


<h2>Returning pointers to automatic variables</h2>
<div class="highlight"><pre><span class="kt">int</span> <span class="o">*</span><span class="nf">f</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="n">imok</span><span class="p">;</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="n">imok</span><span class="p">;</span> <span class="c1">// OK - static variables are not on the stack</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="n">result</span><span class="p">;</span> <span class="c1">// Not OK</span>
<span class="p">}</span>
</pre></div>


<p>Automatic variables are bound to stack memory only for the lifetime of the function.<br />
After the function returns it is an error to continue to use the memory.</p>
<h2>Insufficient memory allocation</h2>
<div class="highlight"><pre><span class="k">struct</span> <span class="n">User</span> <span class="p">{</span>
   <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">User</span> <span class="kt">user_t</span><span class="p">;</span>

<span class="kt">user_t</span> <span class="o">*</span><span class="n">user</span> <span class="o">=</span> <span class="p">(</span><span class="kt">user_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">user</span><span class="p">));</span>
</pre></div>


<p>In the above example, we needed to allocate enough bytes for the struct. Instead we allocated enough bytes to hold a pointer. Once we start using the user pointer we will corrupt memory. Correct code is show below.</p>
<div class="highlight"><pre><span class="k">struct</span> <span class="n">User</span> <span class="p">{</span>
   <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">User</span> <span class="kt">user_t</span><span class="p">;</span>

<span class="kt">user_t</span> <span class="o">*</span> <span class="n">user</span> <span class="o">=</span> <span class="p">(</span><span class="kt">user_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">user_t</span><span class="p">));</span>
</pre></div>


<h4>Strings require <code>strlen(s)+1</code> bytes</h4>
<p>Every string must have a null byte after the last characters. To store the string <code>"Hi"</code> it takes 3 bytes: <code>[H] [i] [\0]</code>.</p>
<div class="highlight"><pre>  <span class="kt">char</span> <span class="o">*</span><span class="nf">strdup</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>  <span class="cm">/* return a copy of &#39;input&#39; */</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">copy</span><span class="p">;</span>
    <span class="n">copy</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">));</span>     <span class="cm">/* nope! this allocates space for a pointer, not a string */</span>
    <span class="n">copy</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">input</span><span class="p">));</span>     <span class="cm">/* Almost...but what about the null terminator? */</span>
    <span class="n">copy</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">input</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span> <span class="cm">/* That&#39;s right. */</span>
    <span class="n">strcpy</span><span class="p">(</span><span class="n">copy</span><span class="p">,</span> <span class="n">input</span><span class="p">);</span>   <span class="cm">/* strcpy will provide the null terminator */</span>
    <span class="k">return</span> <span class="n">copy</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<h2>Using uninitialized variables</h2>
<div class="highlight"><pre><span class="kt">int</span> <span class="nf">myfunction</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">...</span>
</pre></div>


<p>Automatic variables hold garbage (whatever bit pattern happened to be in memory). It is an error to assume that it will always be initialized to zero.</p>
<h2>Assuming Uninitialized memory will be zeroed</h2>
<div class="highlight"><pre><span class="kt">void</span> <span class="nf">myfunct</span><span class="p">()</span> <span class="p">{</span>
   <span class="kt">char</span> <span class="n">array</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
   <span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</pre></div>


<p>Automatic (temporary variables) are not automatically initialized to zero.<br />
Heap allocations using malloc are not automatically initialized to zero.</p>
<h2>Double-free</h2>
<div class="highlight"><pre>  <span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
  <span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="c1">//  .. later ...</span>
  <span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span> 
</pre></div>


<p>It is an error to free the same block of memory twice.</p>
<h2>Dangling pointers</h2>
<div class="highlight"><pre>  <span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
  <span class="n">strcpy</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot;Hello&quot;</span><span class="p">);</span>
  <span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="c1">//  .. later ...</span>
  <span class="n">strcpy</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="s">&quot;World&quot;</span><span class="p">);</span> 
</pre></div>


<p>Pointers to freed memory should not be used. A defensive programming practice is to set pointers to null as soon as the memory is freed.</p>
<p>It is a good idea to turn free into the following snippet that automatically sets the freed variable to null right after:(vim - ultisnips)  </p>
<div class="highlight"><pre>snippet free <span class="s2">&quot;free(something)&quot;</span> <span class="k">b</span>
free<span class="p">(</span>${<span class="m">1</span>}<span class="p">)</span>;
$<span class="m">1</span> <span class="p">=</span> NULL;
${<span class="m">2</span>}
endsnippet
</pre></div>


<h1>Logic and Program flow mistakes</h1>
<h2>Forgetting break</h2>
<div class="highlight"><pre><span class="kt">int</span> <span class="n">flag</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// Will print all three lines.</span>
<span class="k">switch</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">case</span> <span class="mi">1</span><span class="o">:</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;I&#39;m printed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="k">case</span> <span class="mi">2</span><span class="o">:</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Me too</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="k">case</span> <span class="mi">3</span><span class="o">:</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Me three</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>Case statements without a break will just continue onto the code of the next case statement. Correct code is show bellow. The break for the last statements is unnecessary because there are no more cases to be executed after the last one. However if more are added, it can cause some bugs.</p>
<div class="highlight"><pre><span class="kt">int</span> <span class="n">flag</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// Will print all three lines.</span>
<span class="k">switch</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">case</span> <span class="mi">1</span><span class="o">:</span> 
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;I&#39;m printed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="mi">2</span><span class="o">:</span> 
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Me too</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="mi">3</span><span class="o">:</span> 
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Me three</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="k">break</span><span class="p">;</span> <span class="c1">//unnecessary</span>
<span class="p">}</span>
</pre></div>


<h2>Equal vs. equality</h2>
<div class="highlight"><pre><span class="kt">int</span> <span class="n">answer</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="c1">// Will print out the answer.</span>
<span class="k">if</span> <span class="p">(</span><span class="n">answer</span> <span class="o">=</span> <span class="mi">42</span><span class="p">)</span> <span class="p">{</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;I&#39;ve solved the answer! It&#39;s %d&quot;</span><span class="p">,</span> <span class="n">answer</span><span class="p">);}</span>
</pre></div>


<h2>Undeclared or incorrectly prototyped functions</h2>
<div class="highlight"><pre><span class="kt">time_t</span> <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="p">();</span>
</pre></div>


<p>The system function 'time' actually takes a parameter (a pointer to some memory that can receive the time_t structure). The compiler did not catch this error because the programmer did not provide a valid function prototype by including <code>time.h</code></p>
<h2>Extra Semicolons</h2>
<div class="highlight"><pre><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">;</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;I&#39;m printed once&quot;</span><span class="p">);</span>
<span class="k">while</span><span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">);</span> <span class="n">x</span><span class="o">++</span> <span class="p">;</span> <span class="c1">// X is never incremented</span>
</pre></div>


<p>However, the following code is perfectly OK.</p>
<div class="highlight"><pre><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);;;;;;;;;;;;;</span>
<span class="p">}</span>
</pre></div>


<p>It is OK to have this kind of code, because the C language uses semicolons (;) to separate statements. If there is no statement in between semicolons, then there is nothing to do and the compiler moves on to the next statement</p>
<h1>Other Gotchas</h1>
<h2>C Preprocessor macros and side-effects</h2>
<div class="highlight"><pre><span class="cp">#define min(a,b) ((a)&lt;(b) ? (a) : (b))</span>
<span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="k">if</span><span class="p">(</span><span class="n">min</span><span class="p">(</span><span class="n">x</span><span class="o">++</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d is six&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
</pre></div>


<p>Macros are simple text substitution so the above example expands to <code>x++ &lt; 100 ? x++ : 100</code> (parenthesis omitted for clarity)</p>
<h2>C Preprocessor macros and precedence</h2>
<div class="highlight"><pre><span class="cp">#define min(a,b) a&lt;b ? a : b</span>
<span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">99</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">+</span> <span class="n">min</span><span class="p">(</span><span class="mi">99</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span> <span class="c1">// r is 100!</span>
</pre></div>


<p>Macros are simple text substitution so the above example expands to <code>10 + 99 &lt; 100 ? 99 : 100</code></p>
<h2>Assignments in Conditions</h2>
<div class="highlight"><pre><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;What is a?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>Notice the second line--<code>a = 1</code> vs. <code>a == 1</code>. What happens here? The assignment operator in C returns the value on the right. So in this case, <code>if (a = 1)</code> evaluates to <code>if (1)</code>.</p>
    <script src="check_mc.js"></script>
</body>
</html>
</body>
</html>
