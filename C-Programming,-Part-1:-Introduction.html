<!doctype html>
<!--
  Material Design Lite
  Copyright 2015 Google Inc. All rights reserved.

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      https://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License
-->
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="description" content="A front-end template that helps you build fast, modern mobile web apps.">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>C Programming, Part 1: Introduction</title>

    <!-- Add to homescreen for Chrome on Android -->
    <meta name="mobile-web-app-capable" content="yes">
    <link rel="icon" sizes="192x192" href="images/android-desktop.png">

    <!-- Add to homescreen for Safari on iOS -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="Material Design Lite">
    <link rel="apple-touch-icon-precomposed" href="images/ios-desktop.png">

    <!-- Tile icon for Win8 (144x144 + tile color) -->
    <meta name="msapplication-TileImage" content="images/touch/ms-touch-icon-144x144-precomposed.png">
    <meta name="msapplication-TileColor" content="#3372DF">

    <link rel="shortcut icon" href="images/favicon.png">

    <!-- SEO: If your mobile URL is different from the desktop URL, add a canonical link to the desktop page https://developers.google.com/webmasters/smartphone-sites/feature-phones -->
    <!--
    <link rel="canonical" href="http://www.example.com/">
    -->

    <link href='//fonts.googleapis.com/css?family=Roboto:regular,bold,italic,thin,light,bolditalic,black,medium&amp;lang=en' rel='stylesheet' type='text/css'>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons"
      rel="stylesheet">
    <link rel="stylesheet" href="material.min.css">
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="http://yui.yahooapis.com/pure/0.6.0/buttons-min.css">
  </head>
  <body>
    <div class="demo-layout mdl-layout mdl-layout--fixed-header mdl-js-layout mdl-color--grey-100">
      <header class="demo-header mdl-layout__header mdl-layout__header--scroll mdl-color--grey-100 mdl-color-text--grey-800">
        <div class="mdl-layout__header-row">
        <span class="mdl-layout-title">C Programming, Part 1: Introduction</span>
          <div class="mdl-layout-spacer"></div>
          <div class="mdl-textfield mdl-js-textfield mdl-textfield--expandable">
            <label class="mdl-button mdl-js-button mdl-button--icon" for="search">
              <i class="material-icons">search</i>
            </label>
          </div>
        </div>
      </header>
      <div class="demo-ribbon"></div>
      <main class="demo-main mdl-layout__content">
        <div class="demo-container mdl-grid">
          <div class="mdl-cell mdl-cell--2-col mdl-cell--hide-tablet mdl-cell--hide-phone"></div>
          <div class="demo-content mdl-color--white mdl-shadow--4dp content mdl-color-text--grey-800 mdl-cell mdl-cell--8-col">
            <div class="demo-crumbs mdl-color-text--grey-500">
                CS 241 &gt; Wikibook &gt; C Programming, Part 1: Introduction
            </div>
            <h3>C Programming, Part 1: Introduction</h3>

<h1>Want a quick introduction to C?</h1>
<ul>
<li>Keep reading for the quick crash-course to C Programming below</li>
<li>Then see the [[C Gotchas wiki page|C Programming, Part 3: Common Gotchas]].</li>
<li>And learn about [[text I/O|C Programming, Part 2: Text Input And Output]].</li>
<li>Kick back relax with <a href="http://cs-education.github.io/sys/#">Lawrence's intro videos</a></li>
<li>^ and the same link includes a virtual machine-in-a-browser you can play with</li>
<li>Or watch some old CS241 slides <a href="https://subversion.ews.illinois.edu/svn/fa14-cs241/_shared/past-lectures/">CS241 Old Slides</a></li>
</ul>
<h1>External resources</h1>
<ul>
<li><a href="http://www.ccs.neu.edu/course/com3620/parent/C-for-Java-C++/c-for-c++-alt.html">C for C++/Java Programmers</a></li>
<li><a href="http://www.lysator.liu.se/c/bwk-tutor.html">C Tutorial by Brian Kernighan</a></li>
<li><a href="http://c-faq.com/">c faq</a></li>
<li><a href="http://gribblelab.org/CBootCamp/index.html">C Bootcamp</a></li>
<li><a href="http://www.cplusplus.com/reference/clibrary/">C/C++ function reference</a></li>
<li><a href="http://www.unknownroad.com/rtfm/gdbtut/gdbtoc.html">gdb (Gnu debugger) tutorial</a> Tip: run gdb with the "-tui" command line argument to get a full screen version of the debugger.</li>
<li>Add your favorite resources here</li>
</ul>
<h1>Crash course intro to C</h1>
<p><em>Warning new page</em> Please fix typos and formatting mistakes for me and add useful links too.*</p>
<h2>How do you write a complete hello world program in C?</h2>
<div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> 
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hello World</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> 
<span class="p">}</span>
</pre></div>


<h2>Why do we use '<code>#include stdio.h</code>'?</h2>
<p>We're lazy! We don't want to declare the <code>printf</code> function. It's already done for us inside the file '<code>stdio.h</code>'. The #include includes the text of the file as part of our file to be compiled.</p>
<h2>How are C strings represented?</h2>
<p>As characters in memory.  The end of the string includes a NULL (0) byte. So "ABC" requires four(4) bytes. The only way to find out the length of a C string is to keep reading memory until you find the NULL byte. C characters are always exactly one byte each.</p>
<p>When you write a string literal <code>"ABC"</code> in an expression the string literal evaluates to a char pointer (char *), which points to the first byte/char of the string.  This means <code>ptr</code> in the example below will hold the memory address of the first character in the string.</p>
<div class="highlight"><pre><span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="s">&quot;ABC&quot;</span>
</pre></div>


<h2>How do you declare a pointer?</h2>
<p>A pointer refers to a memory address. The type of the pointer is useful - it tells the compiler how many bytes need to be read/written.</p>
<div class="highlight"><pre>int *ptr1;
char *ptr2;
</pre></div>


<h2>How do you use a pointer to read/write some memory?</h2>
<p>if 'p' is a pointer then use "*p" to write to the memory address(es) pointed to by p.</p>
<div class="highlight"><pre><span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// Writes some memory.</span>
</pre></div>


<p>The number of bytes written depends on the pointer type.</p>
<h2>What is pointer arithmetic?</h2>
<p>You can add an integer to a pointer. However the pointer type is used to determine how much to increment the pointer. For char pointers this is trivial because characters are always one byte:</p>
<div class="highlight"><pre><span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="s">&quot;Hello&quot;</span><span class="p">;</span> <span class="c1">// ptr holds the memory location of &#39;H&#39;</span>
<span class="n">ptr</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">//ptr now points to the first&#39;l&#39;</span>
</pre></div>


<p>If an int is 4 bytes then ptr+1 points to 4 bytes after whatever ptr is pointing at.</p>
<div class="highlight"><pre><span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="s">&quot;ABCDEFGH&quot;</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">bna</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">ptr</span><span class="p">;</span>
<span class="n">bna</span> <span class="o">+=</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// Would cause iterate by one integer space (i.e 4 bytes on some systems)</span>
<span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">bna</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
<span class="cm">/* Notice how only &#39;EFGH&#39; is printed. Why is that? Well as mentioned above, when performing &#39;bna+=1&#39; we are increasing the **integer** pointer by 1, (translates to 4 bytes on most systems) which is equivalent to 4 characters (each character is only 1 byte)*/</span>
<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</pre></div>


<p>Because pointer arithmetic in C is always automatically scaled by the size of the type that is pointed to, you can't perform pointer arithmetic on void pointers.</p>
<h2>What is a void pointer?</h2>
<p>A pointer without a type (very similar to a void variable). You can think of this as a raw pointer, or just a memory address. You cannot directly read or write to it because the void type does not have a size.</p>
<p>This is often used when either a datatype you're dealing with is unknown or when you're interfacing C code with other programming languages.</p>
<h2>Does <code>printf</code> call write or does write call <code>printf</code>?</h2>
<p><code>printf</code> calls <code>write</code>. <code>printf</code> includes an internal buffer so, to increase performance <code>printf</code> may not call <code>write</code> everytime you call <code>printf</code>. <code>printf</code> is a C library function. <code>write</code> is a system call and as we know system calls are expensive. On the other hand <code>printf</code> uses a buffer which suits our needs better at that point</p>
<h2>How do you print out pointer values? integers? strings?</h2>
<p>Use format specifiers "%p" for pointers, "%d" for integers and "%s" for Strings.<br />
A full list of all of the format specifiers is found <a href="http://www.cplusplus.com/reference/cstdio/printf/">here</a></p>
<p>Example of integer:</p>
<div class="highlight"><pre><span class="kt">int</span> <span class="n">num1</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">num1</span><span class="p">);</span> <span class="c1">//prints num1</span>
</pre></div>


<p>Example of integer pointer:</p>
<div class="highlight"><pre><span class="kt">int</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span> <span class="c1">//prints the address pointed to by the pointer</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ptr</span><span class="p">);</span> <span class="cm">/*prints the address of pointer -- extremely useful</span>
<span class="cm">when dealing with double pointers*/</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">ptr</span><span class="p">);</span> <span class="c1">//prints the integer content of ptr</span>
<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</pre></div>


<p>Example of string:</p>
<div class="highlight"><pre><span class="kt">char</span> <span class="o">*</span><span class="n">str</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">256</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">));</span>
<span class="n">strcpy</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;Hello there!&quot;</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span> <span class="c1">// print the address in the heap</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>
<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</pre></div>


<p><a href="https://www.cs.bu.edu/teaching/c/string/intro/">Strings as Pointers &amp; Arrays @ BU</a></p>
<h2>How would you make standard out be saved to a file?</h2>
<p>Simplest way: run your program and use shell redirection<br />
e.g.</p>
<div class="highlight"><pre>./program &gt; output.txt

#To read the contents of the file,
cat output.txt
</pre></div>


<p>More complicated way: close(1) and then use open to re-open the file descriptor.<br />
See [[<a href="http://cs-education.github.io/sys/#chapter/0/section/3/activity/0">http://cs-education.github.io/sys/#chapter/0/section/3/activity/0</a>]]</p>
<h2>What's the difference between a pointer and an array? Give an example of something you can do with one but not the other.</h2>
<div class="highlight"><pre>char ary[] = &quot;Hello&quot;;
char *ptr = &quot;Hello&quot;;
</pre></div>


<p>Example </p>
<p>The array name points to the first byte of the array. Both <code>ary</code> and <code>ptr</code> can be printed out:</p>
<div class="highlight"><pre><span class="kt">char</span> <span class="n">ary</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;Hello&quot;</span><span class="p">;</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="s">&quot;Hello&quot;</span><span class="p">;</span>
<span class="c1">// Print out address and contents</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%p : %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ary</span><span class="p">,</span> <span class="n">ary</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%p : %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
</pre></div>


<p>The array is mutable, so we can change its contents (be careful not to write bytes beyond the end of the array though). Fortunately 'World' is no longer than 'Hello"</p>
<p>In this case, the char pointer <code>ptr</code> points to some read only memory (where the statically allocated string literal is stored), so we cannot change those contents.</p>
<div class="highlight"><pre>strcpy(ary, &quot;World&quot;); // OK
strcpy(ptr, &quot;World&quot;); // NOT OK - Segmentation fault (crashes)
</pre></div>


<p>We can, however, unlike the array, we change <code>ptr</code> to point to another piece of memory,</p>
<div class="highlight"><pre>ptr = &quot;World&quot;; // OK!
ptr = ary; // OK!
ary = (..anything..) ; // WONT COMPILE
// ary is doomed to always refer to the original array.
printf(&quot;%p : %s\n&quot;, ptr, ptr);
strcpy(ptr, &quot;World&quot;); // OK because now ptr is pointing to mutable memory (the array)
</pre></div>


<p>What to take away from this is that pointers * can point to any type of memory while C arrays [] can only point to memory on the stack. In a more common case, pointers will point to heap memory in which case the memory referred to by the pointer CAN be modified.</p>
<h2><code>sizeof()</code> returns the number of bytes. So using above code, what is sizeof(ary) and sizeof(ptr)?</h2>
<p><code>sizeof(ary)</code>: <code>ary</code> is an array. Returns the number of bytes required for the entire array (5 chars + zero byte = 6 bytes)<br />
<code>sizeof(ptr)</code>: Same as sizeof(char *). Returns the number bytes required for a pointer (e.g. 4 or 8 for a 32 bit or 64 bit machine)</p>
<h2>Which of the following code is incorrect or correct and why?</h2>
<div class="highlight"><pre><span class="kt">int</span><span class="o">*</span> <span class="nf">f1</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span> <span class="c1">// This code is correct;</span>
</pre></div>


<div class="highlight"><pre><span class="kt">char</span><span class="o">*</span> <span class="nf">f2</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">p</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;Hello&quot;</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span> <span class="c1">// Incorrect!</span>
</pre></div>


<p>Explanation: An array p is created on the stack for the correct size to hold H,e,l,l,o, and a null byte i.e. (6) bytes. This array is stored on the stack and is invalid after we return from f2.</p>
<div class="highlight"><pre><span class="kt">char</span><span class="o">*</span> <span class="nf">f3</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="s">&quot;Hello&quot;</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span> <span class="c1">// OK</span>
</pre></div>


<p>Explanation: p is a pointer. It holds the address of the string constant. The string constant is unchanged and valid even after f3 returns.</p>
<div class="highlight"><pre><span class="kt">char</span><span class="o">*</span> <span class="nf">f4</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">static</span> <span class="kt">char</span> <span class="n">p</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;Hello&quot;</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span> <span class="c1">// OK</span>
</pre></div>


<p>Explanation: The array is static meaning it exists for the lifetime of the process (static variables are not on the heap or the stack).</p>
<h2>How do you look up information C library calls and system calls?</h2>
<p>Use the man pages. Note the man pages are organized into sections. Section 2 = System calls. Section 3 = C libraries.<br />
Web: Google "man7 open"<br />
shell: man -S2 open  or man -S3 printf</p>
<h2>How do you allocate memory on the heap?</h2>
<p>Use malloc. There's also realloc and calloc.<br />
Typically used with sizeof. e.g. enough space to hold 10 integers</p>
<div class="highlight"><pre><span class="kt">int</span> <span class="o">*</span><span class="n">space</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span> <span class="mi">10</span><span class="p">);</span>
</pre></div>


<h2>What's wrong with this string copy code?</h2>
<div class="highlight"><pre><span class="kt">void</span> <span class="nf">mystrcpy</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="n">dest</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">src</span><span class="p">)</span> <span class="p">{</span> 
  <span class="c1">// void means no return value   </span>
  <span class="k">while</span><span class="p">(</span> <span class="o">*</span><span class="n">src</span> <span class="p">)</span> <span class="p">{</span> <span class="n">dest</span> <span class="o">=</span> <span class="n">src</span><span class="p">;</span> <span class="n">src</span> <span class="o">++</span><span class="p">;</span> <span class="n">dest</span><span class="o">++</span><span class="p">;</span> <span class="p">}</span>  
<span class="p">}</span>
</pre></div>


<p>In the above code it simply changes the dest pointer to point to source string. Also the nul bytes is not copied. Here's a better version - </p>
<div class="highlight"><pre>  while( *src ) { *dest = *src; src ++; dest++; } 
  *dest = *src;
</pre></div>


<p>Note it's also usual to see the following kind of implementation, which does everything inside the expression test, including copying the nul byte.</p>
<div class="highlight"><pre>  <span class="k">while</span><span class="p">(</span> <span class="p">(</span><span class="o">*</span><span class="n">dest</span><span class="o">++</span> <span class="o">=</span> <span class="o">*</span><span class="n">src</span><span class="o">++</span> <span class="p">))</span> <span class="p">{};</span>
</pre></div>


<h2>How do you write a strdup replacement?</h2>
<div class="highlight"><pre><span class="c1">// Use strlen+1 to find the zero byte... </span>
<span class="kt">char</span><span class="o">*</span> <span class="nf">mystrdup</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="n">source</span><span class="p">)</span> <span class="p">{</span>
   <span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span> <span class="p">(</span> <span class="n">strlen</span><span class="p">(</span><span class="n">source</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span> <span class="p">);</span>
   <span class="n">strcpy</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">source</span><span class="p">);</span>
   <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<h2>How do you unallocate memory on the heap?</h2>
<p>Use free!</p>
<div class="highlight"><pre><span class="kt">int</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="c1">//Do some work</span>
<span class="n">free</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
</pre></div>


<h2>What is double free error? How can you avoid? What is a dangling pointer? How do you avoid?</h2>
<p>A double free error is when you accidentally attempt to free the same allocation twice.</p>
<div class="highlight"><pre><span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span> <span class="c1">// Oops! - Dangling pointer! Writing to memory we don&#39;t own anymore</span>

<span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span> <span class="c1">// Oops! - Double free!</span>
</pre></div>


<p>The fix is firstly to write correct programs! Secondly, it's good programming hygiene to reset pointers<br />
once the memory has been freed. This ensures the pointer cant be used incorrectly without the program crashing.</p>
<p>Fix:</p>
<div class="highlight"><pre><span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="c1">// Now you can&#39;t use this pointer by mistake</span>
</pre></div>


<h2>What is an example of buffer overflow?</h2>
<p>Famous example: Heart Bleed (performed a memcpy into a buffer that was of insufficient size).<br />
Simple example: implement a strcpy and forget to add one to strlen, when determining the size of the memory required.</p>
<h2>What is 'typedef' and how do you use it?</h2>
<p>Declares an alias for a type. Often used with structs to reduce the visual clutter of having to write 'struct' as part of the type.</p>
<div class="highlight"><pre><span class="k">typedef</span> <span class="kt">float</span> <span class="n">real</span><span class="p">;</span> 
<span class="n">real</span> <span class="n">gravity</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="c1">// Also typedef gives us an abstraction over the underlying type used. </span>
<span class="c1">// For example in the future we only need to change this typedef if we</span>
<span class="c1">// wanted our physics library to use doubles instead of floats.</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">link</span> <span class="kt">link_t</span><span class="p">;</span> 
<span class="c1">//With structs, include the keyword &#39;struct&#39; as part of the original types</span>
</pre></div>          </div>
        </div>
      </main>
    </div>
    <script src="check_mc.js"></script>
  </body>
</html>