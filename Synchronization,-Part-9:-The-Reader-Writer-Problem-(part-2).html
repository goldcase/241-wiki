<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<link rel="stylesheet" href="http://yui.yahooapis.com/pure/0.6.0/pure-min.css">
	<link rel="stylesheet" href="style.css">
    <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
</head>
<body>
<h2>The introduction</h2>
<p>The reader-writer problem appears in many different contexts. For example a web server cache needs to quickly serve the same static page for many thousands of requests. Occasionally however an author may decide to update the page.</p>
<p>We will examine one specific form of the reader-writer problem where there are many readers and some occasional writers and we need to ensure that a writer gets exclusive access. For performance however readers should be able to perform the read without waiting for another reader. </p>
<p>See [[Synchronization,-Part-7:-The-Reader-Writer-Problem]] for part 1</p>
<h2>Candidate solution #3</h2>
<p>Candidate solutions 1 and 2 are discussed in [[part 1|Synchronization,-Part-7:-The-Reader-Writer-Problem]].</p>
<p>In the code below for clarity <code>lock</code> and <code>cond_wait</code> are shortened versions <code>pthread_mutex_lock</code> and <code>pthread_cond_wait</code> etc. respectively</p>
<p>Also remember that <code>pthread_cond_wait</code> performs <em>Three</em> actions. Firstly it atomically unlocks the mutex and then sleeps (until it is woken by <code>pthread_cond_signal</code> or <code>pthread_cond_broadcast</code>). Thirdly the awoken thread must re-acquire the mutex lock before returning. Thus only one thread can actually be running inside the critical section defined by the lock and unlock() methods.</p>
<p>Implementation #3 below ensures that a reader will enter the cond_wait if there are any writers writing.</p>
<div class="highlight"><pre><span class="n">read</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">writing</span><span class="p">)</span>
        <span class="n">cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>
    <span class="n">reading</span><span class="o">++</span><span class="p">;</span>

<span class="cm">/* Read here! */</span>

    <span class="n">reading</span><span class="o">--</span>
    <span class="n">cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cv</span><span class="p">)</span>
    <span class="n">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<p>However only one reader a time can read because candidate #3 did not unlock the mutex. A better version unlocks before reading :</p>
<div class="highlight"><pre><span class="n">read</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">writing</span><span class="p">)</span>
        <span class="n">cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>
    <span class="n">reading</span><span class="o">++</span><span class="p">;</span>
    <span class="n">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>
<span class="cm">/* Read here! */</span>
    <span class="n">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>
    <span class="n">reading</span><span class="o">--</span>
    <span class="n">cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cv</span><span class="p">)</span>
    <span class="n">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<p>Does this mean that a writer and read could read and write at the same time? No! First of all, remember cond_wait requires the thread re-acquire the  mutex lock before returning. Thus only one thread can be executing code inside the critical section (marked with **) at a time!</p>
<div class="highlight"><pre><span class="n">read</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
<span class="o">**</span>  <span class="k">while</span> <span class="p">(</span><span class="n">writing</span><span class="p">)</span>
<span class="o">**</span>      <span class="n">cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>
<span class="o">**</span>  <span class="n">reading</span><span class="o">++</span><span class="p">;</span>
    <span class="n">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>
<span class="cm">/* Read here! */</span>
    <span class="n">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>
<span class="o">**</span>  <span class="n">reading</span><span class="o">--</span>
<span class="o">**</span>  <span class="n">cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cv</span><span class="p">)</span>
    <span class="n">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<p>Writers must wait for everyone. Mutual exclusion is assured by the lock. </p>
<div class="highlight"><pre><span class="n">write</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
<span class="o">**</span>  <span class="nf">while</span> <span class="p">(</span><span class="n">reading</span> <span class="o">||</span> <span class="n">writing</span><span class="p">)</span>
<span class="o">**</span>      <span class="n">cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
<span class="o">**</span>  <span class="n">writing</span><span class="o">++</span><span class="p">;</span>
<span class="o">**</span>
<span class="o">**</span> <span class="cm">/* Write here! */</span>
<span class="o">**</span>  <span class="n">writing</span><span class="o">--</span><span class="p">;</span>
<span class="o">**</span>  <span class="nf">cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cv</span><span class="p">);</span>
    <span class="n">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>Candidate #3 above also uses <code>pthread_cond_signal</code> ; this will only wake up one thread. For example, if many readers are waiting for the writer to complete then only one sleeping reader will be awoken from their slumber. The reader and writer should use <code>cond_broadcast</code> so that all threads should wake up and check their while-loop condition.</p>
<h2>Starving writers</h2>
<p>Candidate #3 above suffers from starvation. If readers are constantly arriving then a writer will never be able to proceed (the 'reading' count never reduces to zero). This is known as <em>starvation</em> and would be discovered under heavy loads. Our fix is to implement a bounded-wait for the writer. If a writer arrives they will still need to wait for existing readers however future readers must be placed in a "holding pen" and wait for the writer to finish. The "holding pen" can be implemented using a variable and a condition variable (so that we can wake up the threads once the writer has finished).</p>
<p>Our plan is that when a writer arrives, and before waiting for current readers to finish, register our intent to write (by incrementing a counter 'writer'). Sketched below - </p>
<div class="highlight"><pre><span class="n">write</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">lock</span><span class="p">()</span>
    <span class="n">writer</span><span class="o">++</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">reading</span> <span class="o">||</span> <span class="n">writing</span><span class="p">)</span>
    <span class="n">cond_wait</span>
    <span class="n">unlock</span><span class="p">()</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>


<p>And incoming readers will not be allowed to continue while writer is nonzero. Notice 'writer' indicates a writer has arrived, while 'reading' and 'writing' counters indicate there is an <em>active</em> reader or writer.</p>
<div class="highlight"><pre><span class="n">read</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">lock</span><span class="p">()</span>
    <span class="c1">// readers that arrive *after* the writer arrived will have to wait here!</span>
    <span class="k">while</span><span class="p">(</span><span class="n">writer</span><span class="p">)</span>
    <span class="n">cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cv</span><span class="p">,</span><span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>

    <span class="c1">// readers that arrive while there is an active writer</span>
    <span class="c1">// will also wait.</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">writing</span><span class="p">)</span> 
        <span class="n">cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cv</span><span class="p">,</span><span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>
    <span class="n">reading</span><span class="o">++</span>
    <span class="n">unlock</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>


<h2>Candidate solution #4</h2>
<p>Below is our first working solution to the Reader-Writer problem. <br />
Note if you continue to read about the "Reader Writer problem" then you will discover that we solved the "Second Reader Writer problem" by giving writers preferential access to the lock. This solution is not optimal. However it satisfies our original problem (N active readers, single active writer, avoids starvation of the writer if there is a constant stream of readers). </p>
<p>Can you identify any improvements? For example, how would you improve the code so that we only woke up readers or one writer? </p>
<div class="highlight"><pre><span class="kt">int</span> <span class="n">writers</span><span class="p">;</span> <span class="c1">// Number writer threads that want to enter the critical section (some or all of these may be blocked)</span>
<span class="kt">int</span> <span class="n">writing</span><span class="p">;</span> <span class="c1">// Number of threads that are actually writing inside the C.S. (can only be zero or one)</span>
<span class="kt">int</span> <span class="n">reading</span><span class="p">;</span> <span class="c1">// Number of threads that are actually reading inside the C.S.</span>
<span class="c1">// if writing !=0 then reading must be zero (and vice versa)</span>

<span class="n">reader</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">writers</span><span class="p">)</span>
        <span class="n">cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">turn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>
    <span class="c1">// No need to wait while(writing here) because we can only exit the above loop</span>
    <span class="c1">// when writing is zero</span>
    <span class="n">reading</span><span class="o">++</span>
    <span class="n">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>

  <span class="c1">// perform reading here</span>

    <span class="n">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>
    <span class="n">reading</span><span class="o">--</span>
    <span class="n">cond_broadcast</span><span class="p">(</span><span class="o">&amp;</span><span class="n">turn</span><span class="p">)</span>
    <span class="n">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>
<span class="p">}</span>

<span class="n">writer</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>  
    <span class="n">writers</span><span class="o">++</span>  
    <span class="k">while</span> <span class="p">(</span><span class="n">reading</span> <span class="o">||</span> <span class="n">writing</span><span class="p">)</span>   
        <span class="n">cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">turn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>  
    <span class="n">writing</span><span class="o">++</span>  
    <span class="n">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>  
    <span class="c1">// perform writing here  </span>
    <span class="n">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>  
    <span class="n">writing</span><span class="o">--</span>  
    <span class="n">writers</span><span class="o">--</span>  
    <span class="n">cond_broadcast</span><span class="p">(</span><span class="o">&amp;</span><span class="n">turn</span><span class="p">)</span>  
    <span class="n">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>  
<span class="p">}</span>
</pre></div>
    <script src="check_mc.js"></script>
</body>
</html>
</body>
</html>
