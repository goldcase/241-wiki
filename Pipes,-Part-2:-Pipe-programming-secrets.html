<!doctype html>
<!  
  Material Design Lite
  Copyright 2015 Google Inc. All rights reserved.

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      https://www.apache.org/licenses/LICENSE 2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License
  >
<html lang="en">
  <head>
    <meta charset="utf 8">
    <meta http equiv="X UA Compatible" content="IE=edge">
    <meta name="description" content="A front end template that helps you build fast, modern mobile web apps.">
    <meta name="viewport" content="width=device width, initial scale=1">
    <title>Pipes, Part 2: Pipe programming secrets</title>

    <!   Add to homescreen for Chrome on Android   >
    <meta name="mobile web app capable" content="yes">
    <link rel="icon" sizes="192x192" href="images/android desktop.png">

    <!   Add to homescreen for Safari on iOS   >
    <meta name="apple mobile web app capable" content="yes">
    <meta name="apple mobile web app status bar style" content="black">
    <meta name="apple mobile web app title" content="Material Design Lite">
    <link rel="apple touch icon precomposed" href="images/ios desktop.png">

    <!   Tile icon for Win8 (144x144 + tile color)   >
    <meta name="msapplication TileImage" content="images/touch/ms touch icon 144x144 precomposed.png">
    <meta name="msapplication TileColor" content="#3372DF">

    <link rel="shortcut icon" href="images/favicon.png">

    <!   SEO: If your mobile URL is different from the desktop URL, add a canonical link to the desktop page https://developers.google.com/webmasters/smartphone sites/feature phones   >
    <!  
    <link rel="canonical" href="http://www.example.com/">
      >

    <link href='//fonts.googleapis.com/css?family=Roboto:regular,bold,italic,thin,light,bolditalic,black,medium&amp;lang=en' rel='stylesheet' type='text/css'>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons"
      rel="stylesheet">
    <link rel="stylesheet" href="material.min.css">
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="http://yui.yahooapis.com/pure/0.6.0/buttons min.css">
  </head>
  <body>
    <div class="demo layout mdl layout mdl layout  fixed header mdl js layout mdl color  grey 100">
      <header class="demo header mdl layout__header mdl layout__header  scroll mdl color  grey 100 mdl color text  grey 800">
        <div class="mdl layout__header row">
        <span class="mdl layout title">Pipes, Part 2: Pipe programming secrets</span>
          <div class="mdl layout spacer"></div>
          <div class="mdl textfield mdl js textfield mdl textfield  expandable">
            <label class="mdl button mdl js button mdl button  icon" for="search">
              <i class="material icons">search</i>
            </label>
          </div>
        </div>
      </header>
      <div class="demo ribbon"></div>
      <main class="demo main mdl layout__content">
        <div class="demo container mdl grid">
          <div class="mdl cell mdl cell  2 col mdl cell  hide tablet mdl cell  hide phone"></div>
          <div class="demo content mdl color  white mdl shadow  4dp content mdl color text  grey 800 mdl cell mdl cell  8 col">
            <div class="demo crumbs mdl color text  grey 500">
                CS 241 &gt; Wikibook &gt; Pipes, Part 2: Pipe programming secrets
            </div>
            <h3>Pipes, Part 2: Pipe programming secrets</h3>

<h2>Pipe Gotchas (1)</h2>
<p>Here's a complete example that doesn't work! The child reads one byte at a time from the pipe and prints it out - but we never see the message! Can you see why?</p>
<div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;stdlib.h&gt;</span>
<span class="cp">#include &lt;unistd.h&gt;</span>
<span class="cp">#include &lt;signal.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">fd</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="n">pipe</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
    <span class="c1">//You must read from fd[0] and write from fd[1]</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Reading from %d, writing to %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">fd</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

    <span class="kt">pid_t</span> <span class="n">p</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* I have a child therefore I am the parent*/</span>
        <span class="n">write</span><span class="p">(</span><span class="n">fd</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="s">&quot;Hi Child!&quot;</span><span class="p">,</span><span class="mi">9</span><span class="p">);</span>

        <span class="cm">/*don&#39;t forget your child*/</span>
        <span class="n">wait</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="kt">char</span> <span class="n">buf</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">bytesread</span><span class="p">;</span>
        <span class="c1">// read one byte at a time.</span>
        <span class="k">while</span> <span class="p">((</span><span class="n">bytesread</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">putchar</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>The parent sends the bytes <code>H,i,(space),C...!</code> into the pipe (this may block if the pipe is full).<br />
The child starts reading the pipe one byte at a time. In the above case, the child process will read and print each character. However it never leaves the while loop! When there are no characters left to read it simply blocks and waits for more. The call <code>putchar</code> writes the characters out but we never flush the buffer.</p>
<p>To see the message we could flush the buffer (e.g. fflush(stdout) or printf("\n"))<br />
or better, let's look for the end of message '!'</p>
<div class="highlight"><pre>        <span class="k">while</span> <span class="p">((</span><span class="n">bytesread</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">putchar</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">buf</span> <span class="o">==</span> <span class="sc">&#39;!&#39;</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span> <span class="cm">/* End of message */</span>
        <span class="p">}</span>
</pre></div>


<p>And the message will be flushed to the terminal when the child process exits.</p>
<h2>Want to use pipes with printf and scanf? Use fdopen!</h2>
<p>POSIX file descriptors are simple integers 0,1,2,3...<br />
At the C library level, C wraps these with a buffer and useful functions like printf and scanf, so we that we can easily print or parse integers, strings etc.<br />
If you already have a file descriptor then you can 'wrap' it yourself into a FILE pointer using <code>fdopen</code> :</p>
<div class="highlight"><pre><span class="cp">#include &lt;sys/types.h&gt;</span>
<span class="cp">#include &lt;sys/stat.h&gt;</span>
<span class="cp">#include &lt;fcntl.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;Fred&quot;</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">score</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">filedes</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">&quot;mydata.txt&quot;</span><span class="p">,</span> <span class="s">&quot;w&quot;</span><span class="p">,</span> <span class="n">O_CREAT</span><span class="p">,</span> <span class="n">S_IWUSR</span> <span class="o">|</span> <span class="n">S_IRUSR</span><span class="p">);</span>

    <span class="kt">FILE</span> <span class="o">*</span><span class="n">f</span> <span class="o">=</span> <span class="n">fdopen</span><span class="p">(</span><span class="n">filedes</span><span class="p">,</span> <span class="s">&quot;w&quot;</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">&quot;Name:%s Score:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">score</span><span class="p">);</span>
    <span class="n">fclose</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
</pre></div>


<p>For writing to files this is unnecessary - just use <code>fopen</code> which does the same as <code>open</code> and <code>fdopen</code><br />
However for pipes, we already have a file descriptor - so this is great time to use <code>fdopen</code>!</p>
<p>Here's a complete example using pipes that almost works! Can you spot the error? Hint: The parent never prints anything!</p>
<div class="highlight"><pre><span class="cp">#include &lt;unistd.h&gt;</span>
<span class="cp">#include &lt;stdlib.h&gt;</span>
<span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">fh</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="n">pipe</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>
    <span class="kt">FILE</span> <span class="o">*</span><span class="n">reader</span> <span class="o">=</span> <span class="n">fdopen</span><span class="p">(</span><span class="n">fh</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s">&quot;r&quot;</span><span class="p">);</span>
    <span class="kt">FILE</span> <span class="o">*</span><span class="n">writer</span> <span class="o">=</span> <span class="n">fdopen</span><span class="p">(</span><span class="n">fh</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">&quot;w&quot;</span><span class="p">);</span>
    <span class="kt">pid_t</span> <span class="n">p</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">score</span><span class="p">;</span>
        <span class="n">fscanf</span><span class="p">(</span><span class="n">reader</span><span class="p">,</span> <span class="s">&quot;Score %d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">score</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;The child says the score is %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">score</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">writer</span><span class="p">,</span> <span class="s">&quot;Score %d&quot;</span><span class="p">,</span> <span class="mi">10</span> <span class="o">+</span> <span class="mi">10</span><span class="p">);</span>
        <span class="n">fflush</span><span class="p">(</span><span class="n">writer</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>Note the (unnamed) pipe resource will disappear once both the child and parent have exited. In the above example the child will send the bytes and the parent will receive the bytes from the pipe. However, no end-of-line character is ever sent, so <code>fscanf</code> will continue to ask for bytes because it is waiting for the end of the line i.e. it will wait forever! The fix is to ensure we send a newline character, so that <code>fscanf</code> will return.</p>
<div class="highlight"><pre><span class="nl">change</span><span class="p">:</span>   <span class="n">fprintf</span><span class="p">(</span><span class="n">writer</span><span class="p">,</span> <span class="s">&quot;Score %d&quot;</span><span class="p">,</span> <span class="mi">10</span> <span class="o">+</span> <span class="mi">10</span><span class="p">);</span>
<span class="nl">to</span><span class="p">:</span>       <span class="n">fprintf</span><span class="p">(</span><span class="n">writer</span><span class="p">,</span> <span class="s">&quot;Score %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">10</span> <span class="o">+</span> <span class="mi">10</span><span class="p">);</span>
</pre></div>


<p>So do we need to <code>fflush</code> too?<br />
Yes, if you want your bytes to be sent to the pipe immediately! At the beginning of this course we assumed that file streams are always <em>line buffered</em> i.e. the C library will flush its buffer everytime you send a newline character. Actually this is only true for terminal streams - for other filestreams the C library attempts to improve performance by only flushing when it's internal buffer is full or the file is closed.</p>
<h2>When do I need two pipes?</h2>
<p>If you need to send data to and from a child asynchronously, then two pipes are required (one for each direction).<br />
Otherwise the child would attempt to read its own data intended for the parent (and vice versa)!</p>
<h2>Closing pipes gotchas</h2>
<p>Processes receive the signal SIGPIPE when no process is listening! From the pipe(2) man page - </p>
<div class="highlight"><pre>If all file descriptors referring to the read end of a pipe have been closed,
 then a write(2) will cause a SIGPIPE signal to be generated for the calling process. 
</pre></div>


<p>Tip: Notice only the writer (not a reader) can use this signal.<br />
To inform the reader that a writer is closing their end of the pipe, you could write your own special byte (e.g. 0xff) or a message ( <code>"Bye!"</code>)</p>
<p>Here's an example of catching this signal that does not work! Can you see why?</p>
<div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;unistd.h&gt;</span>
<span class="cp">#include &lt;signal.h&gt;</span>

<span class="kt">void</span> <span class="nf">no_one_listening</span><span class="p">(</span><span class="kt">int</span> <span class="n">signal</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">write</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;No one is listening!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">21</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">signal</span><span class="p">(</span><span class="n">SIGPIPE</span><span class="p">,</span> <span class="n">no_one_listening</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">filedes</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

    <span class="n">pipe</span><span class="p">(</span><span class="n">filedes</span><span class="p">);</span>
    <span class="kt">pid_t</span> <span class="n">child</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">child</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> 
        <span class="cm">/* I must be the parent. Close the listening end of the pipe */</span>
        <span class="cm">/* I&#39;m not listening anymore!*/</span>
        <span class="n">close</span><span class="p">(</span><span class="n">filedes</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="cm">/* Child writes messages to the pipe */</span>
        <span class="n">write</span><span class="p">(</span><span class="n">filedes</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">&quot;One&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
        <span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
        <span class="c1">// Will this write generate SIGPIPE ?</span>
        <span class="n">write</span><span class="p">(</span><span class="n">filedes</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">&quot;Two&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
        <span class="n">write</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Done</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>The mistake in above code is that there is still a reader for the pipe! The child still has the pipe's first file descriptor open and remember the specification? All readers must be closed.</p>
<p>When forking, <em>It is common practice</em> to close the unnecessary (unused) end of each pipe in the child and parent process. For example the parent might close the reading end and the child might close the writing end (and vice versa if you have two pipes)</p>
<h2>The lifetime of pipes</h2>
<p>Unnamed pipes (the kind we've seen up to this point) live in memory (do not take up any disk space) and are a simple and efficient form of inter-process communication (IPC) that is useful for streaming data and simple messages. Once all processes have closed, the pipe resources are freed.</p>
<p>An alternative to <em>unamed</em> pipes is <em>named</em> pipes created using <code>mkfifo</code> - more about these in a future lecture.</p>          </div>
        </div>
      </main>
    </div>
    <script src="check_mc.js"></script>
  </body>
</html>