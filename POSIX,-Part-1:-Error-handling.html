<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<link rel="stylesheet" href="http://yui.yahooapis.com/pure/0.6.0/pure-min.css">
	<link rel="stylesheet" href="style.css">
    <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
</head>
<body>
<h2>What is <code>errno</code> and when is it set?</h2>
<p>POSIX defines a special integer <code>errno</code> that is set when a system call fails.<br />
The initial value of <code>errno</code> is zero (i.e. no error).<br />
When a system call fails it will typically return -1 to indicate an error and set <code>errno</code></p>
<h2>What about multiple threads?</h2>
<p>Each thread has it's own copy of <code>errno</code>. This is very useful; otherwise an error in one thread would interfere with the error status of another thread.</p>
<h2>When is <code>errno</code> reset to zero?</h2>
<p>It's not unless you specifically reset it to zero!  When system calls are successful they do <em>not</em> reset the value of <code>errno</code>.</p>
<p>This means you should only rely on the value of errno if you know a system call has failed (e.g. it returned -1).</p>
<h2>What are the gotchas and best practices of using <code>errno</code>?</h2>
<p>Be careful when complex error handling use of library calls or system calls that may change the value of <code>errno</code>. In practice it's safer to copy the value of errno into a int variable:</p>
<div class="highlight"><pre><span class="c1">// Unsafe - the first fprintf may change the value of errno before we use it!</span>
<span class="k">if</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">==</span> <span class="n">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">))</span> <span class="p">{</span>
   <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;An error occurred!&quot;</span><span class="p">);</span>
   <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;The error value is %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">errno</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// Better, copy the value before making more system and library calls</span>
<span class="k">if</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">==</span> <span class="n">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">))</span> <span class="p">{</span>
   <span class="kt">int</span> <span class="n">errno_saved</span> <span class="o">=</span> <span class="n">errno</span><span class="p">;</span>
   <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;An error occurred!&quot;</span><span class="p">);</span>
   <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;The error value is %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">errno_saved</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>In a similar vein, if your signal handler makes any system or library calls, then it is good practice to save the original value of errno and restore the value before returning:</p>
<div class="highlight"><pre><span class="kt">void</span> <span class="nf">handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">signal</span><span class="p">)</span> <span class="p">{</span>
   <span class="kt">int</span> <span class="n">errno_saved</span> <span class="o">=</span> <span class="n">errno</span><span class="p">;</span>

   <span class="c1">// make system calls that might change errno</span>

   <span class="n">errno</span> <span class="o">=</span> <span class="n">errno_saved</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<h2>How can you print out the string message associated with a particular error number?</h2>
<p>Use <code>strerror</code> to get a short (English) description of the error value</p>
<div class="highlight"><pre><span class="kt">char</span> <span class="o">*</span><span class="n">mesg</span> <span class="o">=</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">);</span>
<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;An error occurred (errno=%d): %s&quot;</span><span class="p">,</span> <span class="n">errno</span><span class="p">,</span> <span class="n">mesg</span><span class="p">);</span>
</pre></div>


<h2>How are perror and strerror related?</h2>
<p>In previous pages we've used perror to print out the error to standard error. Using <code>strerror</code>, we can now write a simple implementation of <code>perror</code>:</p>
<div class="highlight"><pre><span class="kt">void</span> <span class="nf">perror</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">what</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;%s: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">what</span><span class="p">,</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>


<h2>What are the gotchas of using strerror?</h2>
<p>Unfortunately <code>strerror</code> is not threadsafe. In other words, two threads cannot call it at the same time!</p>
<p>There are two workarounds: Firstly we can use a mutex lock to define a critical section and a local buffer. The same mutex should be used by all threads in all places that call <code>strerror</code></p>
<div class="highlight"><pre><span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">);</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">message</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">strcpy</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
<span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;An error occurred (errno=%d): %s&quot;</span><span class="p">,</span> <span class="n">errno</span><span class="p">,</span> <span class="n">message</span><span class="p">);</span>
<span class="n">free</span><span class="p">(</span><span class="n">message</span><span class="p">);</span>
</pre></div>


<p>Alternatively use the less portable but thread-safe <code>strerror_r</code></p>
<h2>What is EINTR? What does it mean for sem_wait? read? write?</h2>
<p>Some system calls can be interrupted when a signal (e.g SIGCHLD, SIGPIPE,...) is delivered to the process. At this point the system call may return without performing any action! For example, bytes may not have been read/written, semaphore wait may not have waited.</p>
<p>This interruption can be detected by checking the return value and if <code>errno</code> is EINTR. In which case the system call should be retried. It's common to see the following kind of loop that wraps a system call (such as sem_wait).</p>
<div class="highlight"><pre><span class="k">while</span> <span class="p">((</span><span class="o">-</span><span class="mi">1</span> <span class="o">==</span> <span class="n">systemcall</span><span class="p">(...))</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">errno</span> <span class="o">==</span> <span class="n">EINTR</span><span class="p">))</span> <span class="p">{</span> <span class="cm">/* repeat! */</span><span class="p">}</span>
</pre></div>


<p>Be careful to write <code>== EINTR</code>, not <code>= EINTR</code>.</p>
<p>Or, if the result value needs to be used later...</p>
<div class="highlight"><pre><span class="k">while</span> <span class="p">((</span><span class="o">-</span><span class="mi">1</span> <span class="o">==</span> <span class="p">(</span><span class="n">result</span> <span class="o">=</span> <span class="n">systemcall</span><span class="p">(...)))</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">errno</span> <span class="o">==</span> <span class="n">EINTR</span><span class="p">))</span> <span class="p">{</span> <span class="cm">/* repeat! */</span><span class="p">}</span>
</pre></div>


<p>On Linux,calling <code>read</code> and <code>write</code> to a local disk will normally not return with EINTR (instead the function is automatically restarted for you). However, calling <code>read</code> and <code>write</code> on a file descriptor that corresponds to a network stream <em>can</em> return with EINTR.</p>
<h2>Which system calls may be interrupted and need to be wrapped?</h2>
<p>Use man the page! The man page includes a list of errors (i.e. errno values) that may be set by the system call. A rule of thumb is 'slow' (blocking) calls (e.g. writing to a socket) may be interrupted but fast non-blocking calls (e.g. pthread_mutex_lock) will not.</p>
<p>From the linux signal 7 man page.</p>
<p>"If a signal handler is invoked while a system call or library function call is blocked, then either:<br />
<em> the call is automatically restarted after the signal handler returns; or<br />
</em> the call fails with the error EINTR.<br />
Which of these two behaviors occurs depends on the interface and whether or not the signal handler was established using the SA_RESTART flag (see sigaction(2)). The details vary across UNIX systems; below, the details for Linux.</p>
<p>If a blocked call to one of the following interfaces is interrupted by a signal handler, then the call will be automatically restarted after the signal handler returns if the SA_RESTART flag was used; otherwise the call will fail with the error EINTR:</p>
<ul>
<li>read(2), readv(2), write(2), writev(2), and ioctl(2) calls on "slow" devices. A "slow" device is one where the I/O call may block for an indefinite time, for example, a terminal, pipe, or socket. (A disk is not a slow device according to this definition.) If an I/O call on a slow device has already transferred some data by the time it is interrupted by a signal handler, then the call will return a success status (normally, the number of bytes transferred).<br />
"</li>
</ul>
<p>Note, it is easy to believe that setting 'SA_RESTART' flag is sufficient to make this whole problem disappear. Unfortunately that's not true: there are still system calls that may return early and set <code>EINTR</code>! See <a href="https://cs-education.github.io/sysassets/man_pages/html/man7/signal.7.html">signal(7)</a> for details. </p>
    <script src="check_mc.js"></script>
</body>
</html>
</body>
</html>
